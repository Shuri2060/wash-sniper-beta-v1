import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.min.js"; (() => { const e = { math: { floatToWeiBig: (e, t) => BigInt(Math.floor(e * 10 ** t)), roundWeiDecimals(e, t) { const n = 10n ** t; return e / n * n }, roundWeiSigfig(e, t) { const n = e.toString(), s = n.slice(0, t) + "0".repeat(Math.max(0, n.length - t)); return BigInt(s) }, weiBigToString(e, t) { const n = e.toString(); if (0 === t) return n; let s; if (n.length > t) { const e = n.length - t; s = n.slice(0, e) + "." + n.slice(e) } else s = "0." + n.padStart(t, "0"); return s = s.replace(/0+$/, ""), "." == s.slice(-1) && (s = s.slice(0, -1)), s }, priceToOrderString(t, n) { let s = e.math.floatToWeiBig(t, 8); return s = e.math.roundWeiDecimals(s, BigInt(n)), s = e.math.roundWeiSigfig(s, 5), e.math.weiBigToString(s, 8) }, sizeToOrderString(t, n) { const s = e.math.floatToWeiBig(t, n); return e.math.weiBigToString(s, n) } }, actions: { orderLimit: ({ asset: e, isBid: t, price: n, size: s, isReduce: a, tif: i, cloid: r }) => ({ a: e, b: t, p: n, s: s, r: a, t: { limit: { tif: i } }, ...void 0 !== r && { c: r } }), actionOrder: ({ orders: e }) => ({ type: "order", orders: e, grouping: "na" }), cancelCloid: ({ asset: e, cloid: t }) => ({ asset: e, cloid: t }), actionCancelCloid: ({ cancels: e }) => ({ type: "cancelByCloid", cancels: e }), actionSetReferrer: ({ code: e }) => ({ type: "setReferrer", code: e }), actionSpotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), actionApproveAgent: ({ agentAddress: e, agentName: t, nonce: s }) => ({ type: "approveAgent", hyperliquidChain: n ? "Mainnet" : "Testnet", signatureChainId: (n, p(c[n])), agentAddress: e, agentName: t, nonce: s }) }, signing: { PHANTOM_DOMAIN: { name: "Exchange", version: "1", chainId: 1337, verifyingContract: "0x0000000000000000000000000000000000000000" }, AGENT_TYPES: { Agent: [{ name: "source", type: "string" }, { name: "connectionId", type: "bytes32" }] }, actionHash({ activePool: e, action: t, nonce: n }) { const s = MessagePack.encode(t), a = new Uint8Array(s.length + (void 0 === e ? 9 : 29)); a.set(s); const i = new DataView(a.buffer); return i.setBigUint64(s.length, BigInt(n), !1), void 0 === e ? i.setUint8(s.length + 8, 0) : (i.setUint8(s.length + 8, 1), a.set(ethers.getBytes(e), s.length + 9)), ethers.keccak256(a) }, async signInnerAsync({ wallet: t, message: n }) { const { r: s, s: a, v: i } = ethers.Signature.from(await t.signTypedData(e.signing.PHANTOM_DOMAIN, e.signing.AGENT_TYPES, n)); return { r: s, s: a, v: i } }, signL1ActionAsync: async ({ isMainnet: t, wallet: n, activePool: s, action: a, nonce: i }) => await e.signing.signInnerAsync({ wallet: n, message: { source: t ? "a" : "b", connectionId: e.signing.actionHash({ activePool: s, action: a, nonce: i }) } }), async signWalletL1ActionAsync({ isMainnet: e, wallet: t, action: s }) { const { r: a, s: i, v: r } = ethers.Signature.from(await window.ethereum.request({ method: "eth_signTypedData_v4", params: [t.address, JSON.stringify({ types: { EIP712Domain: [{ name: "name", type: "string" }, { name: "version", type: "string" }, { name: "chainId", type: "uint256" }, { name: "verifyingContract", type: "address" }], "HyperliquidTransaction:ApproveAgent": [{ name: "hyperliquidChain", type: "string" }, { name: "agentAddress", type: "address" }, { name: "agentName", type: "string" }, { name: "nonce", type: "uint64" }] }, domain: { name: "HyperliquidSignTransaction", version: "1", chainId: c[n], verifyingContract: "0x0000000000000000000000000000000000000000" }, primaryType: "HyperliquidTransaction:ApproveAgent", message: s })] })); return { r: a, s: i, v: r } } }, requests: { payloadExchangeAsync: async ({ isMainnet: t, wallet: n, subaccount: s, action: a, nonce: i }) => ({ action: a, nonce: i, signature: await e.signing.signL1ActionAsync({ isMainnet: t, wallet: n, activePool: s, action: a, nonce: i }), vaultAddress: s }), payloadExchangeWalletAsync: async ({ isMainnet: t, wallet: n, action: s, nonce: a }) => ({ action: s, nonce: a, signature: await e.signing.signWalletL1ActionAsync({ isMainnet: t, wallet: n, action: s }) }), wsMsg: ({ id: e, type: t, payload: n }) => JSON.stringify({ method: "post", id: e, request: { type: t, payload: n } }), postAsync: async ({ url: e, endpoint: t, payload: n }) => await fetch(e + t, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(n) }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postInfoAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/info", payload: n }), postExchangeAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/exchange", payload: n }) } }, t = { import: { keyToWallet(e) { if (null !== e && "" !== e) try { return new ethers.Wallet(e) } catch { return null } }, washAddress: null, washBalance: null, sniperAddress: null, sniperBalance: null, agentWallet: null }, sniper: { orders: [], async queueBuys(s, o) { const l = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: i, isBid: !0, price: e.math.priceToOrderString(s, a), size: e.math.sizeToOrderString(n ? 1e6 : 1e3, a), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < o; s++) { const a = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: l, nonce: Date.now() + s }), i = e.requests.wsMsg({ id: r++, type: "action", payload: a }); t.sniper.orders.push(i) } }, async queueSells(s, o) { const l = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: i, isBid: !1, price: e.math.priceToOrderString(s, a), size: e.math.sizeToOrderString(n ? 5e3 : 1e3, a), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < o; s++) { const a = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: l, nonce: Date.now() + s }), i = e.requests.wsMsg({ id: r++, type: "action", payload: a }); t.sniper.orders.push(i) } }, queueClear() { t.sniper.orders = [] }, async snipe(e) { const t = await m(), s = Math.max(18e4 / (t + 1), 40); e = e.slice(0); const a = new WebSocket(l[n]); a.addEventListener("message", console.log), a.addEventListener("open", (() => { let t = 0; const n = setInterval((function () { t >= e.length ? window.clearInterval(n) : a.send(e[t++]) }), s) })) }, async snipeExecute() { const e = t.sniper.orders; e.length > 0 && (t.sniper.queueClear(), await t.sniper.snipe(e)) }, async snipeAt(e, n) { const s = t.sniper.orders; if (s.length > 0) { document.querySelectorAll("button").forEach((e => e.disabled = !0)), t.sniper.queueClear(), console.log(e); const a = setInterval((async function () { const i = e - Date.now(); if (i <= 0) return window.clearInterval(a), void await t.sniper.snipe(s); n.value = `This will execute ${s.length} orders after ${Math.floor(i / 1e3)} seconds` }), 1e3) } } } }; var n = !0; const s = 1e7, a = 2, i = 1e4 + (n ? 100 : 577); var r = 0; const o = { false: "https://api.hyperliquid-testnet.xyz", true: "https://api.hyperliquid.xyz" }, l = { false: "wss://api.hyperliquid-testnet.xyz/ws", true: "wss://api.hyperliquid.xyz/ws" }, c = { false: 421614, true: 42161 }; function p(e) { return `0x${e.toString(16)}` } async function u(e) { const t = await window.ethereum.request({ method: "eth_requestAccounts" }); return window.ethereum.networkVersion !== e && await async function (e) { await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: p(e) }] }) }(e), t } async function d(t, s) { const a = await e.requests.postInfoAsync({ url: o[n], payload: e.actions.actionSpotClearinghouseState({ user: s }) }); for (let e of a.balances) if (e.token === t) return e.total; return "0" } async function m() { try { const e = await d(67, t.import.washAddress); return t.import.washBalance = e, w.step1.input.washBalance.element.value = e, w.step1.button.washBalanceRefresh.element.disabled = !1, e } catch (e) { console.log("Hyperliquid Error: failed to fetch $WASH balance", e) } } async function g() { try { const e = await d(0, t.import.sniperAddress); return t.import.sniperBalance = e, w.step1.input.sniperBalance.element.value = e, w.step1.button.sniperBalanceRefresh.element.disabled = !1, e } catch (e) { console.log("Hyperliquid Error: failed to fetch $WASH balance", e) } } const y = `$WASH sniper login (${n ? "Mainnet" : "Testnet"})\n\nSign this message to login and confirm ownership of the $WASH in this wallet.\n\nDo **not** share the signature generated by this message with anyone else, or they will have access to your Sniper wallet. Timestamp: ${Date.now()}`, h = "washSniperAgent", w = { step1: { button: { washLogin: { async click(e) { try { const e = await u(c[n]), s = await window.ethereum.request({ method: "personal_sign", params: [y, e[0]] }); t.import.washAddress = e[0]; const a = s.slice(0, 65) + "a"; if (66 !== a.length) throw new Error("bad key"); t.import.agentWallet = t.import.keyToWallet(a), w.step1.input.washAddress.element.value = t.import.washAddress, w.step1.button.washCopy.element.disabled = !1, w.step1.button.sniperConnect.element.disabled = !1, await m() } catch (e) { console.log("Wallet Error: failed to connect $WASH wallet", e) } } }, washCopy: { click(e) { navigator.clipboard.writeText(w.step1.input.washAddress.element.value) } }, washBalanceRefresh: { async click(e) { await m() } }, sniperConnect: { async click(e) { try { const e = await u(c[n]); t.import.sniperAddress = e[0], w.step1.input.sniperAddress.element.value = t.import.sniperAddress, w.step1.button.sniperCopy.element.disabled = !1, w.step1.button.sniperEnable.element.disabled = !1, w.step1.button.sniperDisable.element.disabled = !1, await g() } catch (e) { console.log("Wallet Error: failed to connect sniper wallet", e) } } }, sniperCopy: { click(e) { navigator.clipboard.writeText(w.step1.input.sniperAddress.element.value) } }, sniperBalanceRefresh: { async click(e) { await g() } }, sniperEnable: { async click(s) { const a = t.import.agentWallet.address.toLowerCase(); if (42 === a.length) { const s = Date.now(); await e.requests.postExchangeAsync({ url: o[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: a, agentName: `${h} valid_until ${Date.now() + 864e5}`, nonce: s }), nonce: s }) }), w.step1.msg.errorDuplicateSniper.element.innerHTML = "Enabled sniper", w.step1.msg.errorDuplicateSniper.element.classList.remove("error"), w.step1.msg.errorDuplicateSniper.element.style.visibility = "visible", w.step2.button.queueBuys.element.disabled = !1, w.step2.button.queueSells.element.disabled = !1, w.step2.button.queueClear.element.disabled = !1 } else console.log("faulty agent address"), w.step1.msg.errorDuplicateSniper.element.innerHTML = "agent address error", w.step1.msg.errorDuplicateSniper.element.classList.add("error"), w.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } }, sniperDisable: { async click(s) { const a = Date.now(); await e.requests.postExchangeAsync({ url: o[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: "0x" + "0".repeat(40), agentName: `${h} valid_until ${Date.now() + 864e5}`, nonce: a }), nonce: a }) }), w.step1.msg.errorDuplicateSniper.element.innerHTML = "Disabled sniper", w.step1.msg.errorDuplicateSniper.element.classList.add("error"), w.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } } }, input: { washAddress: {}, washBalance: {}, sniperAddress: {}, sniperBalance: {} }, msg: { errorDuplicateSniper: {} } }, step2: { button: { queueBuys: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(w.step2.input.orderMarketCap.element.value), a = parseFloat(w.step2.input.orderNumber.element.value); w.step2.input.orderMarketCap.element.value = ""; const i = n / s; if (isNaN(n) || isNaN(i) || isNaN(a)) return; if (n <= 1e3 || i <= 0 || a <= 0) return; try { await t.sniper.queueBuys(i, a), w.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, w.step2.textArea.queueList.element.value += `\nBUY  | MC: ${n} (Price: ${i}) Num: ${a}` } catch (e) { console.log(e) } } } }, queueSells: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(w.step2.input.orderMarketCap.element.value), a = parseFloat(w.step2.input.orderNumber.element.value); w.step2.input.orderMarketCap.element.value = ""; const i = n / s; if (isNaN(n) || isNaN(i) || isNaN(a)) return; if (n <= 1e3 || i <= 0 || a <= 0) return; try { t.sniper.queueSells(i, a), w.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, w.step2.textArea.queueList.element.value += `\nSELL | MC: ${n} (Price: ${i}) Num: ${a}` } catch (e) { console.log(e) } } } }, queueClear: { async click(e) { t.sniper.queueClear(), w.step2.input.queueSummary.element.value = "You have 0 orders queued", w.step2.textArea.queueList.element.value = "" } } }, input: { orderMarketCap: {}, orderNumber: {}, queueSummary: {} }, textArea: { queueList: {} } }, step3: { button: { executeNow: { async click(e) { await t.sniper.snipeExecute(), w.step2.input.queueSummary.element.value = "You have 0 orders queued", w.step2.textArea.queueList.element.value = "" } }, executeTimed: { async click(e) { const n = Date.parse(`${(new Date).toISOString().slice(0, 10)}T${w.step3.input.timeStart.element.value}.000Z`); await t.sniper.snipeAt(n, w.step3.input.countdown.element), w.step2.input.queueSummary.element.value = "You have 0 orders queued", w.step2.textArea.queueList.element.value = "" } } }, input: { timeStart: {}, timeEnd: {}, countdown: {} }, msg: { msgExecuting: {} } } }; for (let e in w) for (let t in w[e]) for (let n in w[e][t]) { const s = w[e][t][n]; s.element = document.getElementById(n), "button" === t && s.element.addEventListener("click", s.click) } })()