import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.min.js"; (async () => { const e = { math: { floatToWeiBig: (e, t) => BigInt(Math.floor(e * 10 ** t)), roundWeiDecimals(e, t) { const n = 10n ** t; return e / n * n }, roundWeiSigfig(e, t) { const n = e.toString(), s = n.slice(0, t) + "0".repeat(Math.max(0, n.length - t)); return BigInt(s) }, weiBigToString(e, t) { const n = e.toString(); if (0 === t) return n; let s; if (n.length > t) { const e = n.length - t; s = n.slice(0, e) + "." + n.slice(e) } else s = "0." + n.padStart(t, "0"); return s = s.replace(/0+$/, ""), "." == s.slice(-1) && (s = s.slice(0, -1)), s }, priceToOrderString(t, n) { let s = e.math.floatToWeiBig(t, 8); return s = e.math.roundWeiDecimals(s, BigInt(n)), s = e.math.roundWeiSigfig(s, 5), e.math.weiBigToString(s, 8) }, sizeToOrderString(t, n) { const s = e.math.floatToWeiBig(t, n); return e.math.weiBigToString(s, n) } }, actions: { orderLimit: ({ asset: e, isBid: t, price: n, size: s, isReduce: i, tif: a }) => ({ a: e, b: t, p: n, s: s, r: i, t: { limit: { tif: a } } }), actionOrder: ({ orders: e }) => ({ type: "order", orders: e, grouping: "na" }), cancelCloid: ({ asset: e, cloid: t }) => ({ asset: e, cloid: t }), actionCancelCloid: ({ cancels: e }) => ({ type: "cancelByCloid", cancels: e }), actionSetReferrer: ({ code: e }) => ({ type: "setReferrer", code: e }), actionSpotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), actionApproveAgent: ({ agentAddress: e, agentName: t, nonce: s }) => ({ type: "approveAgent", hyperliquidChain: n ? "Mainnet" : "Testnet", signatureChainId: (n, g(d[n])), agentAddress: e, agentName: t, nonce: s }), info: { spotMeta: ({ }) => ({ type: "spotMeta" }), spotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), referral: ({ user: e }) => ({ type: "referral", user: e }), userRateLimit: ({ user: e }) => ({ type: "userRateLimit", user: e }), spotDeployState: ({ user: e }) => ({ type: "spotDeployState", user: e }) }, spotDeploy: { registerToken({ name: e, szDecimals: t, weiDecimals: n, maxGasE6: s, fullName: i }) { const a = { spec: { name: e, szDecimals: t, weiDecimals: n }, maxGas: s }; return void 0 !== i && (a.fullName = i), { type: "spotDeploy", registerToken2: a } }, userGenesisAction: ({ token: e, user: t, anchor: n }) => ({ type: "spotDeploy", userGenesis: { token: e, userAndWei: t, existingTokenAndWei: n } }), registerSpotAction: ({ baseToken: e, quoteToken: t }) => ({ type: "spotDeploy", registerSpot: { tokens: [e, t] } }), genesisAction: ({ token: e, maxSupply: t }) => ({ type: "spotDeploy", genesis: { token: e, maxSupply: t } }), registerHyperliquidityAction({ spot: e, startPx: t, orderSz: n, nOrders: s, nSeededLevels: i }) { const a = { spot: e, startPx: t, orderSz: n, nOrders: s }; return void 0 !== i && (a.nSeededLevels = i), { type: "spotDeploy", registerHyperliquidity: a } } } }, signing: { PHANTOM_DOMAIN: { name: "Exchange", version: "1", chainId: 1337, verifyingContract: "0x0000000000000000000000000000000000000000" }, AGENT_TYPES: { Agent: [{ name: "source", type: "string" }, { name: "connectionId", type: "bytes32" }] }, actionHash({ activePool: e, action: t, nonce: n }) { const s = MessagePack.encode(t), i = new Uint8Array(s.length + (void 0 === e ? 9 : 29)); i.set(s); const a = new DataView(i.buffer); return a.setBigUint64(s.length, BigInt(n), !1), void 0 === e ? a.setUint8(s.length + 8, 0) : (a.setUint8(s.length + 8, 1), i.set(ethers.getBytes(e), s.length + 9)), ethers.keccak256(i) }, async signInnerAsync({ wallet: t, message: n }) { const { r: s, s: i, v: a } = ethers.Signature.from(await t.signTypedData(e.signing.PHANTOM_DOMAIN, e.signing.AGENT_TYPES, n)); return { r: s, s: i, v: a } }, signL1ActionAsync: async ({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: a }) => await e.signing.signInnerAsync({ wallet: n, message: { source: t ? "a" : "b", connectionId: e.signing.actionHash({ activePool: s, action: i, nonce: a }) } }), async signWalletL1ActionAsync({ isMainnet: e, wallet: t, action: s }) { const { r: i, s: a, v: r } = ethers.Signature.from(await window.ethereum.request({ method: "eth_signTypedData_v4", params: [t.address, JSON.stringify({ types: { EIP712Domain: [{ name: "name", type: "string" }, { name: "version", type: "string" }, { name: "chainId", type: "uint256" }, { name: "verifyingContract", type: "address" }], "HyperliquidTransaction:ApproveAgent": [{ name: "hyperliquidChain", type: "string" }, { name: "agentAddress", type: "address" }, { name: "agentName", type: "string" }, { name: "nonce", type: "uint64" }] }, domain: { name: "HyperliquidSignTransaction", version: "1", chainId: d[n], verifyingContract: "0x0000000000000000000000000000000000000000" }, primaryType: "HyperliquidTransaction:ApproveAgent", message: s })] })); return { r: i, s: a, v: r } } }, requests: { payloadExchangeAsync: async ({ isMainnet: t, wallet: n, subaccount: s, action: i, nonce: a }) => ({ action: i, nonce: a, signature: await e.signing.signL1ActionAsync({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: a }), vaultAddress: s }), payloadExchangeWalletAsync: async ({ isMainnet: t, wallet: n, action: s, nonce: i }) => ({ action: s, nonce: i, signature: await e.signing.signWalletL1ActionAsync({ isMainnet: t, wallet: n, action: s }) }), wsMsg: ({ id: e, type: t, payload: n }) => JSON.stringify({ method: "post", id: e, request: { type: t, payload: n } }), postAsync: async ({ url: e, endpoint: t, payload: n }) => await fetch(e + t, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(n) }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postInfoAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/info", payload: n }), postExchangeAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/exchange", payload: n }) } }, t = { import: { keyToWallet(e) { if (null !== e && "" !== e) try { return new ethers.Wallet(e) } catch { return null } }, washAddress: null, washBalance: "0", sniperAddress: null, sniperBalance: "0", agentWallet: null }, sniper: { orders: [], possibleOrders: {}, async queueBuys(s, l) { if (void 0 !== a) { const r = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + a, isBid: !0, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(o, i), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < l; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: r, nonce: Date.now() + s }), a = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.orders.push(a) } } else for (let a = 0; a <= 10; a++) { const p = r + a; void 0 === t.sniper.possibleOrders[p] && (t.sniper.possibleOrders[p] = []); const u = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + p, isBid: !0, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(o, i), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < l; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: u, nonce: Date.now() + s }), a = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.possibleOrders[p].push(a) } } console.log(t.sniper.possibleOrders) }, async queueSells(s, o) { if (void 0 !== a) { const r = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + a, isBid: !1, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(l, i), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < o; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: r, nonce: Date.now() + s }), a = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.orders.push(a) } } else for (let a = 0; a <= 10; a++) { const p = r + a; void 0 === t.sniper.possibleOrders[p] && (t.sniper.possibleOrders[p] = []); const u = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + p, isBid: !1, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(l, i), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < o; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: u, nonce: Date.now() + s }), a = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.possibleOrders[p].push(a) } } console.log(t.sniper.possibleOrders) }, queueClear() { t.sniper.orders = [], t.sniper.possibleOrders = {} }, async snipe(e) { const t = await h(), s = Math.max(18e4 / (t + 1), 40); e = e.slice(0); const i = new WebSocket(u[n]); i.addEventListener("message", console.log), i.addEventListener("open", (() => { let t = 0; const n = setInterval((function () { t >= e.length ? window.clearInterval(n) : i.send(e[t++]) }), s) })) }, async snipeExecute() { let e; e = void 0 !== a ? t.sniper.orders : t.sniper.possibleOrders[0], e.length > 0 && (t.sniper.queueClear(), await t.sniper.snipe(e)) }, async snipeAt(e, n) { let s; if (s = void 0 !== a ? t.sniper.orders : t.sniper.possibleOrders[0], s.length > 0) { document.querySelectorAll("button").forEach((e => e.disabled = !0)), t.sniper.queueClear(), console.log(e); const i = setInterval((async function () { const a = e - Date.now(); if (a <= 0) return window.clearInterval(i), void await t.sniper.snipe(s); n.value = `This will execute ${s.length} orders after ${Math.floor(a / 1e3)} seconds` }), 1e3) } } } }; var n = !0; const s = 1e6, i = 2; let a = n ? 120 : 577; const r = 120, o = 15e3, l = 1500; var c = 0; const p = { false: "https://api.hyperliquid-testnet.xyz", true: "https://api.hyperliquid.xyz" }, u = { false: "wss://api.hyperliquid-testnet.xyz/ws", true: "wss://api.hyperliquid.xyz/ws" }, d = { false: 421614, true: 42161 }; function g(e) { return `0x${e.toString(16)}` } async function m(e) { const t = await window.ethereum.request({ method: "eth_requestAccounts" }); return window.ethereum.networkVersion !== e && await async function (e) { await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: g(e) }] }) }(e), t } async function y(t, s) { const i = await e.requests.postInfoAsync({ url: p[n], payload: e.actions.info.spotClearinghouseState({ user: s }) }); for (let e of i.balances) if (e.token === t) return String(parseFloat(e.total) - parseFloat(e.hold)); return "0" } async function h() { try { const e = await y(67, t.import.washAddress); return t.import.washBalance = e, v.step1.input.washBalance.element.value = e, v.step1.button.washBalanceRefresh.element.disabled = !1, e } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } async function w() { try { const e = await y(0, t.import.sniperAddress); return t.import.sniperBalance = e, v.step1.input.sniperBalance.element.value = e, v.step1.button.sniperBalanceRefresh.element.disabled = !1, e } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } const f = `$WASH sniper login (${n ? "Mainnet" : "Testnet"})\n\nSign this message to login and confirm ownership of the $WASH in this wallet.\n\nDo **not** share the signature generated by this message with anyone else, or they will have access to your Sniper wallet.\n\nSniping PICKL 2024/12/09 14:00`, A = "washSniperAgent", v = { step1: { button: { washLogin: { async click(e) { try { const e = await m(d[n]), s = await window.ethereum.request({ method: "personal_sign", params: [f, e[0]] }); t.import.washAddress = e[0]; const i = s.slice(0, 65) + "a"; if (66 !== i.length) throw new Error("bad key"); t.import.agentWallet = t.import.keyToWallet(i), v.step1.input.washAddress.element.value = t.import.washAddress, v.step1.button.washCopy.element.disabled = !1, v.step1.button.sniperConnect.element.disabled = !1, await h() } catch (e) { console.log("Wallet Error: failed to connect $WASH wallet", e) } } }, washCopy: { click(e) { navigator.clipboard.writeText(v.step1.input.washAddress.element.value) } }, washBalanceRefresh: { async click(e) { await h() } }, sniperConnect: { async click(e) { try { const e = await m(d[n]); t.import.sniperAddress = e[0], v.step1.input.sniperAddress.element.value = t.import.sniperAddress, v.step1.button.sniperCopy.element.disabled = !1, v.step1.button.sniperEnable.element.disabled = !1, v.step1.button.sniperDisable.element.disabled = !1, await w() } catch (e) { console.log("Wallet Error: failed to connect sniper wallet", e) } } }, sniperCopy: { click(e) { navigator.clipboard.writeText(v.step1.input.sniperAddress.element.value) } }, sniperBalanceRefresh: { async click(e) { await w() } }, sniperEnable: { async click(s) { const i = t.import.agentWallet.address.toLowerCase(); if (42 === i.length) { const s = Date.now(); await e.requests.postExchangeAsync({ url: p[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: i, agentName: `${A} valid_until ${Date.now() + 864e5}`, nonce: s }), nonce: s }) }), v.step1.msg.errorDuplicateSniper.element.innerHTML = "Enabled sniper", v.step1.msg.errorDuplicateSniper.element.classList.remove("error"), v.step1.msg.errorDuplicateSniper.element.style.visibility = "visible", v.step2.button.queueBuys.element.disabled = !1, v.step2.button.queueSells.element.disabled = !1, v.step2.button.queueClear.element.disabled = !1 } else console.log("faulty agent address"), v.step1.msg.errorDuplicateSniper.element.innerHTML = "agent address error", v.step1.msg.errorDuplicateSniper.element.classList.add("error"), v.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } }, sniperDisable: { async click(s) { const i = Date.now(); await e.requests.postExchangeAsync({ url: p[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: "0x" + "0".repeat(40), agentName: `${A} valid_until ${Date.now() + 864e5}`, nonce: i }), nonce: i }) }), v.step1.msg.errorDuplicateSniper.element.innerHTML = "Disabled sniper", v.step1.msg.errorDuplicateSniper.element.classList.add("error"), v.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } } }, input: { washAddress: {}, washBalance: {}, sniperAddress: {}, sniperBalance: {} }, msg: { errorDuplicateSniper: {} } }, step2: { button: { queueBuys: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(v.step2.input.orderMarketCap.element.value), i = parseFloat(v.step2.input.orderNumber.element.value); v.step2.input.orderMarketCap.element.value = ""; const a = n / s; if (isNaN(n) || isNaN(a) || isNaN(i)) return; if (n <= 0 || a <= 0 || i <= 0) return; try { await t.sniper.queueBuys(a, i), v.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, v.step2.textArea.queueList.element.value += `\nBUY  | MC: ${n} (Price: ${a}) Num: ${i}` } catch (e) { console.log(e) } } } }, queueSells: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(v.step2.input.orderMarketCap.element.value), i = parseFloat(v.step2.input.orderNumber.element.value); v.step2.input.orderMarketCap.element.value = ""; const a = n / s; if (isNaN(n) || isNaN(a) || isNaN(i)) return; if (n <= 0 || a <= 0 || i <= 0) return; try { t.sniper.queueSells(a, i), v.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, v.step2.textArea.queueList.element.value += `\nSELL | MC: ${n} (Price: ${a}) Num: ${i}` } catch (e) { console.log(e) } } } }, queueClear: { async click(e) { t.sniper.queueClear(), v.step2.input.queueSummary.element.value = "You have 0 orders queued", v.step2.textArea.queueList.element.value = "" } } }, input: { orderMarketCap: {}, orderNumber: {}, queueSummary: {} }, textArea: { queueList: {} } }, step3: { button: { executeNow: { async click(e) { v.step3.msg.msgExecuting.element.classList.add("show"), await t.sniper.snipeExecute(), v.step2.input.queueSummary.element.value = "You have 0 orders queued", v.step2.textArea.queueList.element.value = "", v.step3.msg.msgExecuting.element.classList.remove("show") } }, executeTimed: { async click(e) { const n = Date.parse(`${(new Date).toISOString().slice(0, 10)}T${v.step3.input.timeStart.element.value}.000Z`); await t.sniper.snipeAt(n, v.step3.input.countdown.element), v.step2.input.queueSummary.element.value = "You have 0 orders queued", v.step2.textArea.queueList.element.value = "" } } }, input: { timeStart: {}, timeEnd: {}, countdown: {} }, msg: { msgExecuting: {} } } }; for (let e in v) for (let t in v[e]) for (let n in v[e][t]) { const s = v[e][t][n]; s.element = document.getElementById(n), "button" === t && s.element.addEventListener("click", s.click) } })()