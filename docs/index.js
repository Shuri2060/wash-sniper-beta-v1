import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.min.js"; (async () => { const e = { math: { floatToWeiBig: (e, t) => BigInt(Math.floor(e * 10 ** t)), roundWeiDecimals(e, t) { const n = 10n ** t; return e / n * n }, roundWeiSigfig(e, t) { const n = e.toString(), s = n.slice(0, t) + "0".repeat(Math.max(0, n.length - t)); return BigInt(s) }, weiBigToString(e, t) { const n = e.toString(); if (0 === t) return n; let s; if (n.length > t) { const e = n.length - t; s = n.slice(0, e) + "." + n.slice(e) } else s = "0." + n.padStart(t, "0"); return s = s.replace(/0+$/, ""), "." == s.slice(-1) && (s = s.slice(0, -1)), s }, priceToOrderString(t, n) { let s = e.math.floatToWeiBig(t, 8); return s = e.math.roundWeiDecimals(s, BigInt(n)), s = e.math.roundWeiSigfig(s, 5), e.math.weiBigToString(s, 8) }, sizeToOrderString(t, n) { const s = e.math.floatToWeiBig(t, n); return e.math.weiBigToString(s, n) } }, actions: { orderLimit: ({ asset: e, isBid: t, price: n, size: s, isReduce: i, tif: r }) => ({ a: e, b: t, p: n, s: s, r: i, t: { limit: { tif: r } } }), actionOrder: ({ orders: e }) => ({ type: "order", orders: e, grouping: "na" }), cancelCloid: ({ asset: e, cloid: t }) => ({ asset: e, cloid: t }), actionCancelCloid: ({ cancels: e }) => ({ type: "cancelByCloid", cancels: e }), actionSetReferrer: ({ code: e }) => ({ type: "setReferrer", code: e }), actionSpotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), actionApproveAgent({ agentAddress: e, agentName: t, nonce: s }) { return { type: "approveAgent", hyperliquidChain: n ? "Mainnet" : "Testnet", signatureChainId: (i = n, m(g[i])), agentAddress: e, agentName: t, nonce: s }; var i }, info: { spotMeta: ({ }) => ({ type: "spotMeta" }), spotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), referral: ({ user: e }) => ({ type: "referral", user: e }), userRateLimit: ({ user: e }) => ({ type: "userRateLimit", user: e }), spotDeployState: ({ user: e }) => ({ type: "spotDeployState", user: e }) }, spotDeploy: { registerToken({ name: e, szDecimals: t, weiDecimals: n, maxGasE6: s, fullName: i }) { const r = { spec: { name: e, szDecimals: t, weiDecimals: n }, maxGas: s }; return void 0 !== i && (r.fullName = i), { type: "spotDeploy", registerToken2: r } }, userGenesisAction: ({ token: e, user: t, anchor: n }) => ({ type: "spotDeploy", userGenesis: { token: e, userAndWei: t, existingTokenAndWei: n } }), registerSpotAction: ({ baseToken: e, quoteToken: t }) => ({ type: "spotDeploy", registerSpot: { tokens: [e, t] } }), genesisAction: ({ token: e, maxSupply: t }) => ({ type: "spotDeploy", genesis: { token: e, maxSupply: t } }), registerHyperliquidityAction({ spot: e, startPx: t, orderSz: n, nOrders: s, nSeededLevels: i }) { const r = { spot: e, startPx: t, orderSz: n, nOrders: s }; return void 0 !== i && (r.nSeededLevels = i), { type: "spotDeploy", registerHyperliquidity: r } } } }, signing: { PHANTOM_DOMAIN: { name: "Exchange", version: "1", chainId: 1337, verifyingContract: "0x0000000000000000000000000000000000000000" }, AGENT_TYPES: { Agent: [{ name: "source", type: "string" }, { name: "connectionId", type: "bytes32" }] }, actionHash({ activePool: e, action: t, nonce: n }) { const s = MessagePack.encode(t), i = new Uint8Array(s.length + (void 0 === e ? 9 : 29)); i.set(s); const r = new DataView(i.buffer); return r.setBigUint64(s.length, BigInt(n), !1), void 0 === e ? r.setUint8(s.length + 8, 0) : (r.setUint8(s.length + 8, 1), i.set(ethers.getBytes(e), s.length + 9)), ethers.keccak256(i) }, async signInnerAsync({ wallet: t, message: n }) { const { r: s, s: i, v: r } = ethers.Signature.from(await t.signTypedData(e.signing.PHANTOM_DOMAIN, e.signing.AGENT_TYPES, n)); return { r: s, s: i, v: r } }, signL1ActionAsync: async ({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: r }) => await e.signing.signInnerAsync({ wallet: n, message: { source: t ? "a" : "b", connectionId: e.signing.actionHash({ activePool: s, action: i, nonce: r }) } }), async signWalletL1ActionAsync({ isMainnet: e, wallet: t, action: s }) { const { r: i, s: r, v: a } = ethers.Signature.from(await window.ethereum.request({ method: "eth_signTypedData_v4", params: [t.address, JSON.stringify({ types: { EIP712Domain: [{ name: "name", type: "string" }, { name: "version", type: "string" }, { name: "chainId", type: "uint256" }, { name: "verifyingContract", type: "address" }], "HyperliquidTransaction:ApproveAgent": [{ name: "hyperliquidChain", type: "string" }, { name: "agentAddress", type: "address" }, { name: "agentName", type: "string" }, { name: "nonce", type: "uint64" }] }, domain: { name: "HyperliquidSignTransaction", version: "1", chainId: g[n], verifyingContract: "0x0000000000000000000000000000000000000000" }, primaryType: "HyperliquidTransaction:ApproveAgent", message: s })] })); return { r: i, s: r, v: a } } }, requests: { payloadExchangeAsync: async ({ isMainnet: t, wallet: n, subaccount: s, action: i, nonce: r }) => ({ action: i, nonce: r, signature: await e.signing.signL1ActionAsync({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: r }), vaultAddress: s }), payloadExchangeWalletAsync: async ({ isMainnet: t, wallet: n, action: s, nonce: i }) => ({ action: s, nonce: i, signature: await e.signing.signWalletL1ActionAsync({ isMainnet: t, wallet: n, action: s }) }), wsMsg: ({ id: e, type: t, payload: n }) => JSON.stringify({ method: "post", id: e, request: { type: t, payload: n } }), getAsync: async ({ url: e, endpoint: t }) => await fetch(e + t, { method: "GET", headers: { Accept: "application/json", "Content-Type": "application/json" } }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postAsync: async ({ url: e, endpoint: t, payload: n }) => await fetch(e + t, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(n) }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postInfoAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/info", payload: n }), postExchangeAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/exchange", payload: n }) } }, t = { import: { keyToWallet(e) { if (null !== e && "" !== e) try { return new ethers.Wallet(e) } catch { return null } }, washAddress: null, washBalance: "0", sniperAddress: null, sniperBalance: "0", agentWallet: null }, sniper: { orders: [], possibleOrders: {}, async queueBuys(s, r) { if (void 0 !== a) { const o = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + a, isBid: !0, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(Math.min(l, 19e4 / s), i), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < r; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: o, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: p++, type: "action", payload: i }); t.sniper.orders.push(r) } } else for (let a = 0; a <= 10; a++) { const c = o + a; void 0 === t.sniper.possibleOrders[c] && (t.sniper.possibleOrders[c] = []); const u = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + c, isBid: !0, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(Math.min(l, 19e4 / s), i), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < r; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: u, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: p++, type: "action", payload: i }); t.sniper.possibleOrders[c].push(r) } } console.log(t.sniper.possibleOrders) }, async queueSells(s, r) { if (void 0 !== a) { const o = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + a, isBid: !1, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(Math.min(c, 19e5 / s), i), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < r; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: o, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: p++, type: "action", payload: i }); t.sniper.orders.push(r) } } else for (let a = 0; a <= 10; a++) { const l = o + a; void 0 === t.sniper.possibleOrders[l] && (t.sniper.possibleOrders[l] = []); const u = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + l, isBid: !1, price: e.math.priceToOrderString(s, i), size: e.math.sizeToOrderString(Math.min(c, 19e5 / s), i), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < r; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: u, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: p++, type: "action", payload: i }); t.sniper.possibleOrders[l].push(r) } } console.log(t.sniper.possibleOrders) }, queueClear() { t.sniper.orders = [], t.sniper.possibleOrders = {} }, async snipe(e) { const t = w, s = Math.max(18e4 / (t + 1), 40); e = e.slice(0); const i = new WebSocket(d[n]); i.addEventListener("message", console.log), i.addEventListener("open", (() => { let t = 0; const n = setInterval((function () { t >= e.length ? window.clearInterval(n) : i.send(e[t++]) }), s) })) }, async snipeExecute() { let s; if (void 0 !== a) s = t.sniper.orders; else { const i = await e.requests.postInfoAsync({ url: u[n], payload: e.actions.info.spotMeta({}) }); a = i.universe.findLast((e => e.tokens[0] === r)).index, s = t.sniper.possibleOrders[a] } t.sniper.queueClear(), await t.sniper.snipe(s) }, async snipeAt(e, n) { let s; if (s = void 0 !== a ? t.sniper.orders : t.sniper.possibleOrders[o], s.length > 0) { document.querySelectorAll("button").forEach((e => e.disabled = !0)), t.sniper.queueClear(), console.log(e); const i = setInterval((async function () { const r = e - Date.now(); if (r <= 0) return window.clearInterval(i), void await t.sniper.snipe(s); n.value = `This will execute ${s.length} orders after ${Math.floor(r / 1e3)} seconds` }), 1e3) } } } }; var n = !0; const s = 175e7, i = 1, r = 79; let a = n ? 138 : 577; const o = 123, l = 17504e3, c = 437600; var p = 0; const u = { false: "https://api.hyperliquid-testnet.xyz", true: "https://api.hyperliquid.xyz" }, d = { false: "wss://api.hyperliquid-testnet.xyz/ws", true: "wss://api.hyperliquid.xyz/ws" }, g = { false: 421614, true: 42161 }; function m(e) { return `0x${e.toString(16)}` } async function y(e) { const t = await window.ethereum.request({ method: "eth_requestAccounts" }); return window.ethereum.networkVersion !== e && await async function (e) { await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: m(e) }] }) }(e), t } async function h(e, t, n, s) { try { const e = await async function (e) { return import(`./snapshots/${e}.json`, { with: { type: "json" } }).then((e => e.default)) }(t); return console.log(e.holders[s.toLowerCase()]), e.holders[s.toLowerCase()] || 0 } catch (e) { console.error(e) } return 0 } let w = 0; async function f() { try { const e = await async function (e, t, n, s, i, r) { let a; for (let e = 0; e < s; e++) { const t = await h(0, 1737451443 - n * e, 0, r); a = void 0 === a ? t : 2 * t / (1 + s) + a * (1 - 2 / (1 + s)) } return a }(0, Math.floor(Date.now() / 1e3), 86400, 7, 0, t.import.washAddress); return t.import.washBalance = "" + e, b.step1.input.washBalance.element.value = e, b.step1.button.washBalanceRefresh.element.disabled = !1, w = e, e } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } async function v() { try { const s = await async function (t, s) { const i = await e.requests.postInfoAsync({ url: u[n], payload: e.actions.info.spotClearinghouseState({ user: s }) }); for (let e of i.balances) if (e.token === t) return e.total; return "0" }(0, t.import.sniperAddress); return t.import.sniperBalance = s, b.step1.input.sniperBalance.element.value = s, b.step1.button.sniperBalanceRefresh.element.disabled = !1, s } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } const A = `$WASH sniper login (${n ? "Mainnet" : "Testnet"})\n\nSign this message to login and confirm ownership of the $WASH in this wallet.\n\nDo **not** share the signature generated by this message with anyone else, or they will have access to your Sniper wallet.\n\nSniping TIME 2025/01/21`, S = "washSniperAgent", b = { step1: { button: { washLogin: { async click(e) { try { const e = await y(g[n]), s = await window.ethereum.request({ method: "personal_sign", params: [A, e[0]] }); t.import.washAddress = e[0]; const i = s.slice(0, 65) + "a"; if (66 !== i.length) throw new Error("bad key"); t.import.agentWallet = t.import.keyToWallet(i), b.step1.input.washAddress.element.value = t.import.washAddress, b.step1.button.washCopy.element.disabled = !1, b.step1.button.sniperConnect.element.disabled = !1, await f() } catch (e) { console.log("Wallet Error: failed to connect $WASH wallet", e) } } }, washCopy: { click(e) { navigator.clipboard.writeText(b.step1.input.washAddress.element.value) } }, washBalanceRefresh: { async click(e) { await f() } }, sniperConnect: { async click(e) { try { const e = await y(g[n]); t.import.sniperAddress = e[0], b.step1.input.sniperAddress.element.value = t.import.sniperAddress, b.step1.button.sniperCopy.element.disabled = !1, b.step1.button.sniperEnable.element.disabled = !1, b.step1.button.sniperDisable.element.disabled = !1, await v() } catch (e) { console.log("Wallet Error: failed to connect sniper wallet", e) } } }, sniperCopy: { click(e) { navigator.clipboard.writeText(b.step1.input.sniperAddress.element.value) } }, sniperBalanceRefresh: { async click(e) { await v() } }, sniperEnable: { async click(s) { const i = t.import.agentWallet.address.toLowerCase(); if (42 === i.length) { const s = Date.now(); await e.requests.postExchangeAsync({ url: u[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: i, agentName: `${S} valid_until ${Date.now() + 864e5}`, nonce: s }), nonce: s }) }), b.step1.msg.errorDuplicateSniper.element.innerHTML = "Enabled sniper", b.step1.msg.errorDuplicateSniper.element.classList.remove("error"), b.step1.msg.errorDuplicateSniper.element.style.visibility = "visible", b.step2.button.queueBuys.element.disabled = !1, b.step2.button.queueSells.element.disabled = !1, b.step2.button.queueClear.element.disabled = !1 } else console.log("faulty agent address"), b.step1.msg.errorDuplicateSniper.element.innerHTML = "agent address error", b.step1.msg.errorDuplicateSniper.element.classList.add("error"), b.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } }, sniperDisable: { async click(s) { const i = Date.now(); await e.requests.postExchangeAsync({ url: u[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: "0x" + "0".repeat(40), agentName: `${S} valid_until ${Date.now() + 864e5}`, nonce: i }), nonce: i }) }), b.step1.msg.errorDuplicateSniper.element.innerHTML = "Disabled sniper", b.step1.msg.errorDuplicateSniper.element.classList.add("error"), b.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } } }, input: { washAddress: {}, washBalance: {}, sniperAddress: {}, sniperBalance: {} }, msg: { errorDuplicateSniper: {} } }, step2: { button: { queueBuys: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(b.step2.input.orderPrice.element.value), i = parseFloat(b.step2.input.orderNumber.element.value); b.step2.input.orderPrice.element.value = ""; const r = s * n; if (console.log(b.step2.input.orderPrice), isNaN(n) || isNaN(i)) return void console.log(`${n} ${i} nan`); if (n <= 0 || i <= 0) return void console.log(`${n} ${i} <= 0`); try { await t.sniper.queueBuys(n, i), b.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, b.step2.textArea.queueList.element.value += `\nBUY  | Price: ${n} (FDV: ${r / 1e6}M) Num: ${i}` } catch (e) { console.log(e) } } } }, queueSells: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(b.step2.input.orderPrice.element.value), i = parseFloat(b.step2.input.orderNumber.element.value); b.step2.input.orderPrice.element.value = ""; const r = s * n; if (isNaN(n) || isNaN(i)) return void console.log(`${n} ${i} nan`); if (n <= 0 || i <= 0) return void console.log(`${n} ${i} <= 0`); try { t.sniper.queueSells(n, i), b.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, b.step2.textArea.queueList.element.value += `\nSELL | Price: ${n} (FDV: ${r / 1e6}M) Num: ${i}` } catch (e) { console.log(e) } } } }, queueClear: { async click(e) { t.sniper.queueClear(), b.step2.input.queueSummary.element.value = "You have 0 orders queued", b.step2.textArea.queueList.element.value = "" } } }, input: { orderPrice: {}, orderNumber: {}, queueSummary: {} }, textArea: { queueList: {} } }, step3: { button: { executeNow: { async click(e) { b.step3.msg.msgExecuting.element.classList.add("show"), await t.sniper.snipeExecute(), b.step2.input.queueSummary.element.value = "You have 0 orders queued", b.step2.textArea.queueList.element.value = "", b.step3.msg.msgExecuting.element.classList.remove("show") } }, executeTimed: { async click(e) { const n = Date.parse(`${(new Date).toISOString().slice(0, 10)}T${b.step3.input.timeStart.element.value}.000Z`); await t.sniper.snipeAt(n, b.step3.input.countdown.element), b.step2.input.queueSummary.element.value = "You have 0 orders queued", b.step2.textArea.queueList.element.value = "" } } }, input: { timeStart: {}, timeEnd: {}, countdown: {} }, msg: { msgExecuting: {} } } }; for (let e in b) for (let t in b[e]) for (let n in b[e][t]) { const s = b[e][t][n]; s.element = document.getElementById(n), "button" === t && s.element.addEventListener("click", s.click) } })()