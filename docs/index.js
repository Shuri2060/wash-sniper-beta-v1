import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.min.js"; (async () => { const e = { math: { floatToWeiBig: (e, t) => BigInt(Math.floor(e * 10 ** t)), roundWeiDecimals(e, t) { const n = 10n ** t; return e / n * n }, roundWeiSigfig(e, t) { const n = e.toString(), s = n.slice(0, t) + "0".repeat(Math.max(0, n.length - t)); return BigInt(s) }, weiBigToString(e, t) { const n = e.toString(); if (0 === t) return n; let s; if (n.length > t) { const e = n.length - t; s = n.slice(0, e) + "." + n.slice(e) } else s = "0." + n.padStart(t, "0"); return s = s.replace(/0+$/, ""), "." == s.slice(-1) && (s = s.slice(0, -1)), s }, priceToOrderString(t, n) { let s = e.math.floatToWeiBig(t, 8); return s = e.math.roundWeiDecimals(s, BigInt(n)), s = e.math.roundWeiSigfig(s, 5), e.math.weiBigToString(s, 8) }, sizeToOrderString(t, n) { const s = e.math.floatToWeiBig(t, n); return e.math.weiBigToString(s, n) } }, actions: { orderLimit: ({ asset: e, isBid: t, price: n, size: s, isReduce: i, tif: r }) => ({ a: e, b: t, p: n, s: s, r: i, t: { limit: { tif: r } } }), actionOrder: ({ orders: e }) => ({ type: "order", orders: e, grouping: "na" }), cancelCloid: ({ asset: e, cloid: t }) => ({ asset: e, cloid: t }), actionCancelCloid: ({ cancels: e }) => ({ type: "cancelByCloid", cancels: e }), actionSetReferrer: ({ code: e }) => ({ type: "setReferrer", code: e }), actionSpotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), actionApproveAgent({ agentAddress: e, agentName: t, nonce: s }) { return { type: "approveAgent", hyperliquidChain: n ? "Mainnet" : "Testnet", signatureChainId: (i = n, w(r[i])), agentAddress: e, agentName: t, nonce: s }; var i }, info: { spotMeta: ({ }) => ({ type: "spotMeta" }), spotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), referral: ({ user: e }) => ({ type: "referral", user: e }), userRateLimit: ({ user: e }) => ({ type: "userRateLimit", user: e }), spotDeployState: ({ user: e }) => ({ type: "spotDeployState", user: e }) }, spotDeploy: { registerToken({ name: e, szDecimals: t, weiDecimals: n, maxGasE6: s, fullName: i }) { const r = { spec: { name: e, szDecimals: t, weiDecimals: n }, maxGas: s }; return void 0 !== i && (r.fullName = i), { type: "spotDeploy", registerToken2: r } }, userGenesisAction: ({ token: e, user: t, anchor: n }) => ({ type: "spotDeploy", userGenesis: { token: e, userAndWei: t, existingTokenAndWei: n } }), registerSpotAction: ({ baseToken: e, quoteToken: t }) => ({ type: "spotDeploy", registerSpot: { tokens: [e, t] } }), genesisAction: ({ token: e, maxSupply: t }) => ({ type: "spotDeploy", genesis: { token: e, maxSupply: t } }), registerHyperliquidityAction({ spot: e, startPx: t, orderSz: n, nOrders: s, nSeededLevels: i }) { const r = { spot: e, startPx: t, orderSz: n, nOrders: s }; return void 0 !== i && (r.nSeededLevels = i), { type: "spotDeploy", registerHyperliquidity: r } } } }, signing: { PHANTOM_DOMAIN: { name: "Exchange", version: "1", chainId: 1337, verifyingContract: "0x0000000000000000000000000000000000000000" }, AGENT_TYPES: { Agent: [{ name: "source", type: "string" }, { name: "connectionId", type: "bytes32" }] }, actionHash({ activePool: e, action: t, nonce: n }) { const s = MessagePack.encode(t), i = new Uint8Array(s.length + (void 0 === e ? 9 : 29)); i.set(s); const r = new DataView(i.buffer); return r.setBigUint64(s.length, BigInt(n), !1), void 0 === e ? r.setUint8(s.length + 8, 0) : (r.setUint8(s.length + 8, 1), i.set(ethers.getBytes(e), s.length + 9)), ethers.keccak256(i) }, async signInnerAsync({ wallet: t, message: n }) { const { r: s, s: i, v: r } = ethers.Signature.from(await t.signTypedData(e.signing.PHANTOM_DOMAIN, e.signing.AGENT_TYPES, n)); return { r: s, s: i, v: r } }, signL1ActionAsync: async ({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: r }) => await e.signing.signInnerAsync({ wallet: n, message: { source: t ? "a" : "b", connectionId: e.signing.actionHash({ activePool: s, action: i, nonce: r }) } }), async signWalletL1ActionAsync({ isMainnet: e, wallet: t, action: n }) { const { r: s, s: i, v: r } = ethers.Signature.from(await window.ethereum.request({ method: "eth_signTypedData_v4", params: [t.address, JSON.stringify({ types: { EIP712Domain: [{ name: "name", type: "string" }, { name: "version", type: "string" }, { name: "chainId", type: "uint256" }, { name: "verifyingContract", type: "address" }], "HyperliquidTransaction:ApproveAgent": [{ name: "hyperliquidChain", type: "string" }, { name: "agentAddress", type: "address" }, { name: "agentName", type: "string" }, { name: "nonce", type: "uint64" }] }, domain: { name: "HyperliquidSignTransaction", version: "1", chainId: l, verifyingContract: "0x0000000000000000000000000000000000000000" }, primaryType: "HyperliquidTransaction:ApproveAgent", message: n })] })); return { r: s, s: i, v: r } } }, requests: { payloadExchangeAsync: async ({ isMainnet: t, wallet: n, subaccount: s, action: i, nonce: r }) => ({ action: i, nonce: r, signature: await e.signing.signL1ActionAsync({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: r }), vaultAddress: s }), payloadExchangeWalletAsync: async ({ isMainnet: t, wallet: n, action: s, nonce: i }) => ({ action: s, nonce: i, signature: await e.signing.signWalletL1ActionAsync({ isMainnet: t, wallet: n, action: s }) }), wsMsg: ({ id: e, type: t, payload: n }) => JSON.stringify({ method: "post", id: e, request: { type: t, payload: n } }), getAsync: async ({ url: e, endpoint: t }) => await fetch(e + t, { method: "GET", headers: { Accept: "application/json", "Content-Type": "application/json" } }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postAsync: async ({ url: e, endpoint: t, payload: n }) => await fetch(e + t, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(n) }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postInfoAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/info", payload: n }), postExchangeAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/exchange", payload: n }) } }, t = { import: { keyToWallet(e) { if (null !== e && "" !== e) try { return new ethers.Wallet(e) } catch { return null } }, washAddress: null, washBalance: "0", sniperAddress: null, sniperBalance: "0", agentWallet: null }, sniper: { orders: [], possibleOrders: {}, async queueBuys(s, i) { if (void 0 !== d) { const r = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + d, isBid: !0, price: e.math.priceToOrderString(s, p), size: e.math.sizeToOrderString(Math.min(g, 19e4 / s), p), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < i; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: r, nonce: Date.now() + s }), a = e.requests.wsMsg({ id: h++, type: "action", payload: i }); t.sniper.orders.push(a) } } else for (let r = 0; r <= 10; r++) { const a = m + r; void 0 === t.sniper.possibleOrders[a] && (t.sniper.possibleOrders[a] = []); const o = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + a, isBid: !0, price: e.math.priceToOrderString(s, p), size: e.math.sizeToOrderString(Math.min(g, 19e4 / s), p), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < i; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: o, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: h++, type: "action", payload: i }); t.sniper.possibleOrders[a].push(r) } } console.log(t.sniper.possibleOrders) }, async queueSells(s, i) { if (void 0 !== d) { const r = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + d, isBid: !1, price: e.math.priceToOrderString(s, p), size: e.math.sizeToOrderString(Math.min(y, 19e5 / s), p), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < i; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: r, nonce: Date.now() + s }), a = e.requests.wsMsg({ id: h++, type: "action", payload: i }); t.sniper.orders.push(a) } } else for (let r = 0; r <= 10; r++) { const a = m + r; void 0 === t.sniper.possibleOrders[a] && (t.sniper.possibleOrders[a] = []); const o = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + a, isBid: !1, price: e.math.priceToOrderString(s, p), size: e.math.sizeToOrderString(Math.min(y, 19e5 / s), p), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < i; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: o, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: h++, type: "action", payload: i }); t.sniper.possibleOrders[a].push(r) } } console.log(t.sniper.possibleOrders) }, queueClear() { t.sniper.orders = [], t.sniper.possibleOrders = {} }, async snipe(e) { const t = v, n = Math.max(18e4 / (t + 1), 40); e = e.slice(0); const s = new WebSocket(o); s.addEventListener("message", console.log), s.addEventListener("open", (() => { let t = 0; function i() { t >= e.length ? window.clearInterval(r) : s.send(e[t++]) } i(); const r = setInterval(i, n) })) }, async snipeExecute() { let n; if (void 0 !== d) n = t.sniper.orders; else { const s = await e.requests.postInfoAsync({ url: a, payload: e.actions.info.spotMeta({}) }); d = s.universe.findLast((e => e.tokens[0] === u)).index, n = t.sniper.possibleOrders[d] } t.sniper.queueClear(), await t.sniper.snipe(n) }, async snipeAt(e, n) { let s; if (s = void 0 !== d ? t.sniper.orders : t.sniper.possibleOrders[m], s.length > 0) { document.querySelectorAll("button").forEach((e => e.disabled = !0)), t.sniper.queueClear(), console.log(e); const i = setInterval((async function () { const r = e - Date.now(); if (r <= 0) return window.clearInterval(i), void await t.sniper.snipe(s); n.value = `This will execute ${s.length} orders after ${Math.floor(r / 1e3)} seconds` }), 1e3) } } } }; var n = !0; const { URLS: s, URIS: i, CHAIN_IDS: r } = { URLS: { false: "https://api.hyperliquid-testnet.xyz", true: "https://api.hyperliquid.xyz" }, URIS: { false: "wss://api.hyperliquid-testnet.xyz/ws", true: "wss://api.hyperliquid.xyz/ws" }, CHAIN_IDS: { false: 421614, true: 42161 } }; var a = s["" + n], o = i["" + n], l = r["" + n]; const c = 777777777, p = 1, u = 165; let d = n ? 141 : 577; const m = 142, g = 2e7, y = 5e5; var h = 0; function w(e) { return `0x${e.toString(16)}` } async function f(e) { const t = await window.ethereum.request({ method: "eth_requestAccounts" }); return window.ethereum.networkVersion !== e && await async function (e) { await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: w(e) }] }) }(e), t } async function A(t, n, s, i) { try { return (await e.requests.getAsync({ url: "https://api.hypurrscan.io", endpoint: `/holdersAtTimeWithLimit/${t}/${n}/${s}` })).holders[i.toLowerCase()] || 0 } catch (e) { console.error(e) } return 0 } let v = 0; async function S() { try { const e = await async function (e, t, n, s, i, r) { let a; for (let t = 0; t < s; t++) { const o = await A(e, 1737451443 - n * t, i, r); a = void 0 === a ? o : 2 * o / (1 + s) + a * (1 - 2 / (1 + s)) } return a }("WASH", Math.floor(Date.now() / 1e3), 86400, 7, 1e4, t.import.washAddress); return t.import.washBalance = "" + e, D.step1.input.washBalance.element.value = e, D.step1.button.washBalanceRefresh.element.disabled = !1, v = e, e } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } async function q() { try { const n = await async function (t, n) { const s = await e.requests.postInfoAsync({ url: a, payload: e.actions.info.spotClearinghouseState({ user: n }) }); for (let e of s.balances) if (e.token === t) return e.total; return "0" }(0, t.import.sniperAddress); return t.import.sniperBalance = n, D.step1.input.sniperBalance.element.value = n, D.step1.button.sniperBalanceRefresh.element.disabled = !1, n } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } const b = `$WASH sniper login (${n ? "Mainnet" : "Testnet"})\n\nSign this message to login and confirm ownership of the $WASH in this wallet.\n\nDo **not** share the signature generated by this message with anyone else, or they will have access to your Sniper wallet.\n\nSniping GOD 2025/01/24`, T = "washSniperAgent", D = { step1: { button: { washLogin: { async click(e) { try { const e = await f(l), n = await window.ethereum.request({ method: "personal_sign", params: [b, e[0]] }); t.import.washAddress = e[0]; const s = n.slice(0, 65) + "a"; if (66 !== s.length) throw new Error("bad key"); t.import.agentWallet = t.import.keyToWallet(s), D.step1.input.washAddress.element.value = t.import.washAddress, D.step1.button.washCopy.element.disabled = !1, D.step1.button.sniperConnect.element.disabled = !1, await S() } catch (e) { console.log("Wallet Error: failed to connect $WASH wallet", e) } } }, washCopy: { click(e) { navigator.clipboard.writeText(D.step1.input.washAddress.element.value) } }, washBalanceRefresh: { async click(e) { await S() } }, sniperConnect: { async click(e) { try { const e = await f(l); t.import.sniperAddress = e[0], D.step1.input.sniperAddress.element.value = t.import.sniperAddress, D.step1.button.sniperCopy.element.disabled = !1, D.step1.button.sniperEnable.element.disabled = !1, D.step1.button.sniperDisable.element.disabled = !1, await q() } catch (e) { console.log("Wallet Error: failed to connect sniper wallet", e) } } }, sniperCopy: { click(e) { navigator.clipboard.writeText(D.step1.input.sniperAddress.element.value) } }, sniperBalanceRefresh: { async click(e) { await q() } }, sniperEnable: { async click(s) { const i = t.import.agentWallet.address.toLowerCase(); if (42 === i.length) { const s = Date.now(); await e.requests.postExchangeAsync({ url: a, payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: i, agentName: `${T} valid_until ${Date.now() + 864e5}`, nonce: s }), nonce: s }) }), D.step1.msg.errorDuplicateSniper.element.innerHTML = "Enabled sniper", D.step1.msg.errorDuplicateSniper.element.classList.remove("error"), D.step1.msg.errorDuplicateSniper.element.style.visibility = "visible", D.step2.button.queueBuys.element.disabled = !1, D.step2.button.queueSells.element.disabled = !1, D.step2.button.queueClear.element.disabled = !1 } else console.log("faulty agent address"), D.step1.msg.errorDuplicateSniper.element.innerHTML = "agent address error", D.step1.msg.errorDuplicateSniper.element.classList.add("error"), D.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } }, sniperDisable: { async click(s) { const i = Date.now(); await e.requests.postExchangeAsync({ url: a, payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: "0x" + "0".repeat(40), agentName: `${T} valid_until ${Date.now() + 864e5}`, nonce: i }), nonce: i }) }), D.step1.msg.errorDuplicateSniper.element.innerHTML = "Disabled sniper", D.step1.msg.errorDuplicateSniper.element.classList.add("error"), D.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } } }, input: { washAddress: {}, washBalance: {}, sniperAddress: {}, sniperBalance: {} }, msg: { errorDuplicateSniper: {} } }, step2: { button: { queueBuys: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(D.step2.input.orderPrice.element.value), s = parseFloat(D.step2.input.orderNumber.element.value); D.step2.input.orderPrice.element.value = ""; const i = c * n / 1e6; if (console.log(D.step2.input.orderPrice), isNaN(n) || isNaN(s)) return void console.log(`${n} ${s} nan`); if (n <= 0 || s <= 0) return void console.log(`${n} ${s} <= 0`); try { await t.sniper.queueBuys(n, s), D.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, D.step2.textArea.queueList.element.value += `\nBUY  | Price: ${n} (${i}M FDV) Num: ${s}` } catch (e) { console.log(e) } } } }, queueSells: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(D.step2.input.orderPrice.element.value), s = parseFloat(D.step2.input.orderNumber.element.value); D.step2.input.orderPrice.element.value = ""; const i = c * n / 1e6; if (isNaN(n) || isNaN(s)) return void console.log(`${n} ${s} nan`); if (n <= 0 || s <= 0) return void console.log(`${n} ${s} <= 0`); try { t.sniper.queueSells(n, s), D.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, D.step2.textArea.queueList.element.value += `\nSELL | Price: ${n} (${i}M FDV) Num: ${s}` } catch (e) { console.log(e) } } } }, queueClear: { async click(e) { t.sniper.queueClear(), D.step2.input.queueSummary.element.value = "You have 0 orders queued", D.step2.textArea.queueList.element.value = "" } } }, input: { orderPrice: {}, orderNumber: {}, queueSummary: {} }, textArea: { queueList: {} } }, step3: { button: { executeNow: { async click(e) { D.step3.msg.msgExecuting.element.classList.add("show"), await t.sniper.snipeExecute(), D.step2.input.queueSummary.element.value = "You have 0 orders queued", D.step2.textArea.queueList.element.value = "", D.step3.msg.msgExecuting.element.classList.remove("show") } }, executeTimed: { async click(e) { const n = Date.parse(`${(new Date).toISOString().slice(0, 10)}T${D.step3.input.timeStart.element.value}.000Z`); await t.sniper.snipeAt(n, D.step3.input.countdown.element), D.step2.input.queueSummary.element.value = "You have 0 orders queued", D.step2.textArea.queueList.element.value = "" } } }, input: { timeStart: {}, timeEnd: {}, countdown: {} }, msg: { msgExecuting: {} } } }; for (let e in D) for (let t in D[e]) for (let n in D[e][t]) { const s = D[e][t][n]; s.element = document.getElementById(n), "button" === t && s.element.addEventListener("click", s.click) } })()