import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.min.js"; (async () => { const e = { math: { floatToWeiBig: (e, t) => BigInt(Math.floor(e * 10 ** t)), roundWeiDecimals(e, t) { const n = 10n ** t; return e / n * n }, roundWeiSigfig(e, t) { const n = e.toString(), s = n.slice(0, t) + "0".repeat(Math.max(0, n.length - t)); return BigInt(s) }, weiBigToString(e, t) { const n = e.toString(); if (0 === t) return n; let s; if (n.length > t) { const e = n.length - t; s = n.slice(0, e) + "." + n.slice(e) } else s = "0." + n.padStart(t, "0"); return s = s.replace(/0+$/, ""), "." == s.slice(-1) && (s = s.slice(0, -1)), s }, priceToOrderString(t, n) { let s = e.math.floatToWeiBig(t, 8); return s = e.math.roundWeiDecimals(s, BigInt(n)), s = e.math.roundWeiSigfig(s, 5), e.math.weiBigToString(s, 8) }, sizeToOrderString(t, n) { const s = e.math.floatToWeiBig(t, n); return e.math.weiBigToString(s, n) } }, actions: { orderLimit: ({ asset: e, isBid: t, price: n, size: s, isReduce: i, tif: r }) => ({ a: e, b: t, p: n, s: s, r: i, t: { limit: { tif: r } } }), actionOrder: ({ orders: e }) => ({ type: "order", orders: e, grouping: "na" }), cancelCloid: ({ asset: e, cloid: t }) => ({ asset: e, cloid: t }), actionCancelCloid: ({ cancels: e }) => ({ type: "cancelByCloid", cancels: e }), actionSetReferrer: ({ code: e }) => ({ type: "setReferrer", code: e }), actionSpotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), actionApproveAgent: ({ agentAddress: e, agentName: t, nonce: s }) => ({ type: "approveAgent", hyperliquidChain: n ? "Mainnet" : "Testnet", signatureChainId: (n, g(d[n])), agentAddress: e, agentName: t, nonce: s }), info: { spotMeta: ({ }) => ({ type: "spotMeta" }), spotClearinghouseState: ({ user: e }) => ({ type: "spotClearinghouseState", user: e }), referral: ({ user: e }) => ({ type: "referral", user: e }), userRateLimit: ({ user: e }) => ({ type: "userRateLimit", user: e }), spotDeployState: ({ user: e }) => ({ type: "spotDeployState", user: e }) }, spotDeploy: { registerToken({ name: e, szDecimals: t, weiDecimals: n, maxGasE6: s, fullName: i }) { const r = { spec: { name: e, szDecimals: t, weiDecimals: n }, maxGas: s }; return void 0 !== i && (r.fullName = i), { type: "spotDeploy", registerToken2: r } }, userGenesisAction: ({ token: e, user: t, anchor: n }) => ({ type: "spotDeploy", userGenesis: { token: e, userAndWei: t, existingTokenAndWei: n } }), registerSpotAction: ({ baseToken: e, quoteToken: t }) => ({ type: "spotDeploy", registerSpot: { tokens: [e, t] } }), genesisAction: ({ token: e, maxSupply: t }) => ({ type: "spotDeploy", genesis: { token: e, maxSupply: t } }), registerHyperliquidityAction({ spot: e, startPx: t, orderSz: n, nOrders: s, nSeededLevels: i }) { const r = { spot: e, startPx: t, orderSz: n, nOrders: s }; return void 0 !== i && (r.nSeededLevels = i), { type: "spotDeploy", registerHyperliquidity: r } } } }, signing: { PHANTOM_DOMAIN: { name: "Exchange", version: "1", chainId: 1337, verifyingContract: "0x0000000000000000000000000000000000000000" }, AGENT_TYPES: { Agent: [{ name: "source", type: "string" }, { name: "connectionId", type: "bytes32" }] }, actionHash({ activePool: e, action: t, nonce: n }) { const s = MessagePack.encode(t), i = new Uint8Array(s.length + (void 0 === e ? 9 : 29)); i.set(s); const r = new DataView(i.buffer); return r.setBigUint64(s.length, BigInt(n), !1), void 0 === e ? r.setUint8(s.length + 8, 0) : (r.setUint8(s.length + 8, 1), i.set(ethers.getBytes(e), s.length + 9)), ethers.keccak256(i) }, async signInnerAsync({ wallet: t, message: n }) { const { r: s, s: i, v: r } = ethers.Signature.from(await t.signTypedData(e.signing.PHANTOM_DOMAIN, e.signing.AGENT_TYPES, n)); return { r: s, s: i, v: r } }, signL1ActionAsync: async ({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: r }) => await e.signing.signInnerAsync({ wallet: n, message: { source: t ? "a" : "b", connectionId: e.signing.actionHash({ activePool: s, action: i, nonce: r }) } }), async signWalletL1ActionAsync({ isMainnet: e, wallet: t, action: s }) { const { r: i, s: r, v: a } = ethers.Signature.from(await window.ethereum.request({ method: "eth_signTypedData_v4", params: [t.address, JSON.stringify({ types: { EIP712Domain: [{ name: "name", type: "string" }, { name: "version", type: "string" }, { name: "chainId", type: "uint256" }, { name: "verifyingContract", type: "address" }], "HyperliquidTransaction:ApproveAgent": [{ name: "hyperliquidChain", type: "string" }, { name: "agentAddress", type: "address" }, { name: "agentName", type: "string" }, { name: "nonce", type: "uint64" }] }, domain: { name: "HyperliquidSignTransaction", version: "1", chainId: d[n], verifyingContract: "0x0000000000000000000000000000000000000000" }, primaryType: "HyperliquidTransaction:ApproveAgent", message: s })] })); return { r: i, s: r, v: a } } }, requests: { payloadExchangeAsync: async ({ isMainnet: t, wallet: n, subaccount: s, action: i, nonce: r }) => ({ action: i, nonce: r, signature: await e.signing.signL1ActionAsync({ isMainnet: t, wallet: n, activePool: s, action: i, nonce: r }), vaultAddress: s }), payloadExchangeWalletAsync: async ({ isMainnet: t, wallet: n, action: s, nonce: i }) => ({ action: s, nonce: i, signature: await e.signing.signWalletL1ActionAsync({ isMainnet: t, wallet: n, action: s }) }), wsMsg: ({ id: e, type: t, payload: n }) => JSON.stringify({ method: "post", id: e, request: { type: t, payload: n } }), postAsync: async ({ url: e, endpoint: t, payload: n }) => await fetch(e + t, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(n) }).then((e => { if (e.ok) return e.json(); throw new Error("HTTP error") })), postInfoAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/info", payload: n }), postExchangeAsync: async ({ url: t, payload: n }) => await e.requests.postAsync({ url: t, endpoint: "/exchange", payload: n }) } }, t = { import: { keyToWallet(e) { if (null !== e && "" !== e) try { return new ethers.Wallet(e) } catch { return null } }, washAddress: null, washBalance: "0", sniperAddress: null, sniperBalance: "0", agentWallet: null }, sniper: { orders: [], possibleOrders: {}, async queueBuys(i, l) { if (void 0 !== r) { const a = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + r, isBid: !0, price: e.math.priceToOrderString(i, s), size: e.math.sizeToOrderString(o, s), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < l; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: a, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.orders.push(r) } } else for (let r = 0; r <= 10; r++) { const p = a + r; void 0 === t.sniper.possibleOrders[p] && (t.sniper.possibleOrders[p] = []); const u = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + p, isBid: !0, price: e.math.priceToOrderString(i, s), size: e.math.sizeToOrderString(o, s), isReduce: !1, tif: "Ioc" })] }); for (let s = 0; s < l; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: u, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.possibleOrders[p].push(r) } } console.log(t.sniper.possibleOrders) }, async queueSells(i, o) { if (void 0 !== r) { const a = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + r, isBid: !1, price: e.math.priceToOrderString(i, s), size: e.math.sizeToOrderString(l, s), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < o; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: a, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.orders.push(r) } } else for (let r = 0; r <= 10; r++) { const p = a + r; void 0 === t.sniper.possibleOrders[p] && (t.sniper.possibleOrders[p] = []); const u = e.actions.actionOrder({ orders: [e.actions.orderLimit({ asset: 1e4 + p, isBid: !1, price: e.math.priceToOrderString(i, s), size: e.math.sizeToOrderString(l, s), isReduce: !1, tif: "Gtc" })] }); for (let s = 0; s < o; s++) { const i = await e.requests.payloadExchangeAsync({ isMainnet: n, wallet: t.import.agentWallet, action: u, nonce: Date.now() + s }), r = e.requests.wsMsg({ id: c++, type: "action", payload: i }); t.sniper.possibleOrders[p].push(r) } } console.log(t.sniper.possibleOrders) }, queueClear() { t.sniper.orders = [], t.sniper.possibleOrders = {} }, async snipe(e) { const t = await h(), s = Math.max(18e4 / (t + 1), 40); e = e.slice(0); const i = new WebSocket(u[n]); i.addEventListener("message", console.log), i.addEventListener("open", (() => { let t = 0; const n = setInterval((function () { t >= e.length ? window.clearInterval(n) : i.send(e[t++]) }), s) })) }, async snipeExecute() { let s; if (void 0 !== r) s = t.sniper.orders; else { const a = await e.requests.postInfoAsync({ url: p[n], payload: e.actions.info.spotMeta({}) }); r = a.universe.findLast((e => e.tokens[0] === i)).index, s = t.sniper.possibleOrders[r] } t.sniper.queueClear(), await t.sniper.snipe(s) }, async snipeAt(e, n) { let s; if (s = void 0 !== r ? t.sniper.orders : t.sniper.possibleOrders[a], s.length > 0) { document.querySelectorAll("button").forEach((e => e.disabled = !0)), t.sniper.queueClear(), console.log(e); const i = setInterval((async function () { const r = e - Date.now(); if (r <= 0) return window.clearInterval(i), void await t.sniper.snipe(s); n.value = `This will execute ${s.length} orders after ${Math.floor(r / 1e3)} seconds` }), 1e3) } } } }; var n = !0; const s = 2, i = 161; let r = n ? 123 : 577; const a = 123, o = 8e3, l = 800; var c = 0; const p = { false: "https://api.hyperliquid-testnet.xyz", true: "https://api.hyperliquid.xyz" }, u = { false: "wss://api.hyperliquid-testnet.xyz/ws", true: "wss://api.hyperliquid.xyz/ws" }, d = { false: 421614, true: 42161 }; function g(e) { return `0x${e.toString(16)}` } async function m(e) { const t = await window.ethereum.request({ method: "eth_requestAccounts" }); return window.ethereum.networkVersion !== e && await async function (e) { await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: g(e) }] }) }(e), t } async function y(t, s) { const i = await e.requests.postInfoAsync({ url: p[n], payload: e.actions.info.spotClearinghouseState({ user: s }) }); for (let e of i.balances) if (e.token === t) return e.total; return "0" } async function h() { try { const e = await y(67, t.import.washAddress); return t.import.washBalance = e, A.step1.input.washBalance.element.value = e, A.step1.button.washBalanceRefresh.element.disabled = !1, e } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } async function w() { try { const e = await y(0, t.import.sniperAddress); return t.import.sniperBalance = e, A.step1.input.sniperBalance.element.value = e, A.step1.button.sniperBalanceRefresh.element.disabled = !1, e } catch (e) { console.error("Hyperliquid Error: failed to fetch $WASH balance", e) } } const f = `$WASH sniper login (${n ? "Mainnet" : "Testnet"})\n\nSign this message to login and confirm ownership of the $WASH in this wallet.\n\nDo **not** share the signature generated by this message with anyone else, or they will have access to your Sniper wallet.\n\nSniping FARM 2024/12/13 whenever`, v = "washSniperAgent", A = { step1: { button: { washLogin: { async click(e) { try { const e = await m(d[n]), s = await window.ethereum.request({ method: "personal_sign", params: [f, e[0]] }); t.import.washAddress = e[0]; const i = s.slice(0, 65) + "a"; if (66 !== i.length) throw new Error("bad key"); t.import.agentWallet = t.import.keyToWallet(i), A.step1.input.washAddress.element.value = t.import.washAddress, A.step1.button.washCopy.element.disabled = !1, A.step1.button.sniperConnect.element.disabled = !1, await h() } catch (e) { console.log("Wallet Error: failed to connect $WASH wallet", e) } } }, washCopy: { click(e) { navigator.clipboard.writeText(A.step1.input.washAddress.element.value) } }, washBalanceRefresh: { async click(e) { await h() } }, sniperConnect: { async click(e) { try { const e = await m(d[n]); t.import.sniperAddress = e[0], A.step1.input.sniperAddress.element.value = t.import.sniperAddress, A.step1.button.sniperCopy.element.disabled = !1, A.step1.button.sniperEnable.element.disabled = !1, A.step1.button.sniperDisable.element.disabled = !1, await w() } catch (e) { console.log("Wallet Error: failed to connect sniper wallet", e) } } }, sniperCopy: { click(e) { navigator.clipboard.writeText(A.step1.input.sniperAddress.element.value) } }, sniperBalanceRefresh: { async click(e) { await w() } }, sniperEnable: { async click(s) { const i = t.import.agentWallet.address.toLowerCase(); if (42 === i.length) { const s = Date.now(); await e.requests.postExchangeAsync({ url: p[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: i, agentName: `${v} valid_until ${Date.now() + 864e5}`, nonce: s }), nonce: s }) }), A.step1.msg.errorDuplicateSniper.element.innerHTML = "Enabled sniper", A.step1.msg.errorDuplicateSniper.element.classList.remove("error"), A.step1.msg.errorDuplicateSniper.element.style.visibility = "visible", A.step2.button.queueBuys.element.disabled = !1, A.step2.button.queueSells.element.disabled = !1, A.step2.button.queueClear.element.disabled = !1 } else console.log("faulty agent address"), A.step1.msg.errorDuplicateSniper.element.innerHTML = "agent address error", A.step1.msg.errorDuplicateSniper.element.classList.add("error"), A.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } }, sniperDisable: { async click(s) { const i = Date.now(); await e.requests.postExchangeAsync({ url: p[n], payload: await e.requests.payloadExchangeWalletAsync({ isMainnet: n, wallet: { address: t.import.sniperAddress }, action: e.actions.actionApproveAgent({ agentAddress: "0x" + "0".repeat(40), agentName: `${v} valid_until ${Date.now() + 864e5}`, nonce: i }), nonce: i }) }), A.step1.msg.errorDuplicateSniper.element.innerHTML = "Disabled sniper", A.step1.msg.errorDuplicateSniper.element.classList.add("error"), A.step1.msg.errorDuplicateSniper.element.style.visibility = "visible" } } }, input: { washAddress: {}, washBalance: {}, sniperAddress: {}, sniperBalance: {} }, msg: { errorDuplicateSniper: {} } }, step2: { button: { queueBuys: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(A.step2.input.orderPrice.element.value), s = parseFloat(A.step2.input.orderNumber.element.value); if (A.step2.input.orderPrice.element.value = "", console.log(A.step2.input.orderPrice), isNaN(n) || isNaN(s)) return void console.log(`${n} ${s} nan`); if (n <= 0 || s <= 0) return void console.log(`${n} ${s} <= 0`); try { await t.sniper.queueBuys(n, s), A.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, A.step2.textArea.queueList.element.value += `\nBUY  | Price: ${n} Num: ${s}` } catch (e) { console.log(e) } } } }, queueSells: { async click(e) { if (null !== t.import.agentWallet) { const n = parseFloat(A.step2.input.orderPrice.element.value), s = parseFloat(A.step2.input.orderNumber.element.value); if (A.step2.input.orderPrice.element.value = "", isNaN(n) || isNaN(s)) return void console.log(`${n} ${s} nan`); if (n <= 0 || s <= 0) return void console.log(`${n} ${s} <= 0`); try { t.sniper.queueSells(n, s), A.step2.input.queueSummary.element.value = `You have ${t.sniper.orders.length} orders queued`, A.step2.textArea.queueList.element.value += `\nSELL | Price: ${n} Num: ${s}` } catch (e) { console.log(e) } } } }, queueClear: { async click(e) { t.sniper.queueClear(), A.step2.input.queueSummary.element.value = "You have 0 orders queued", A.step2.textArea.queueList.element.value = "" } } }, input: { orderPrice: {}, orderNumber: {}, queueSummary: {} }, textArea: { queueList: {} } }, step3: { button: { executeNow: { async click(e) { A.step3.msg.msgExecuting.element.classList.add("show"), await t.sniper.snipeExecute(), A.step2.input.queueSummary.element.value = "You have 0 orders queued", A.step2.textArea.queueList.element.value = "", A.step3.msg.msgExecuting.element.classList.remove("show") } }, executeTimed: { async click(e) { const n = Date.parse(`${(new Date).toISOString().slice(0, 10)}T${A.step3.input.timeStart.element.value}.000Z`); await t.sniper.snipeAt(n, A.step3.input.countdown.element), A.step2.input.queueSummary.element.value = "You have 0 orders queued", A.step2.textArea.queueList.element.value = "" } } }, input: { timeStart: {}, timeEnd: {}, countdown: {} }, msg: { msgExecuting: {} } } }; for (let e in A) for (let t in A[e]) for (let n in A[e][t]) { const s = A[e][t][n]; s.element = document.getElementById(n), "button" === t && s.element.addEventListener("click", s.click) } })()